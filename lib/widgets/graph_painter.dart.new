import 'package:flutter/material.dart';
import 'dart:math' as math;
import 'package:google_fonts/google_fonts.dart';
import '../models/node.dart';

class GraphVisualizationWidget extends StatefulWidget {
  final Map<int, List<GraphNode>> nodesByDepth;
  final GraphNode? selectedNode;
  final Function(GraphNode) onNodeTap;
  final double availableWidth;
  final double availableHeight;
  final bool isPortrait;

  const GraphVisualizationWidget({
    Key? key,
    required this.nodesByDepth,
    required this.selectedNode,
    required this.onNodeTap,
    required this.availableWidth,
    required this.availableHeight,
    required this.isPortrait,
  }) : super(key: key);

  @override
  _GraphVisualizationWidgetState createState() => _GraphVisualizationWidgetState();
}

class _GraphVisualizationWidgetState extends State<GraphVisualizationWidget> 
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  double _scale = 1.0;
  double _previousScale = 1.0;
  Offset _offset = Offset.zero;
  Offset _previousOffset = Offset.zero;
  bool _isPanning = false;
  Offset? _lastFocalPoint;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onScaleStart: _handleScaleStart,
      onScaleUpdate: _handleScaleUpdate,
      onScaleEnd: _handleScaleEnd,
      onTapDown: (details) {
        final box = context.findRenderObject() as RenderBox;
        final localPosition = box.globalToLocal(details.globalPosition);
        _handleTap(localPosition, box.size);
      },
      child: CustomPaint(
        size: Size(widget.availableWidth, widget.availableHeight),
        painter: AnimatedGraphPainter(
          nodesByDepth: widget.nodesByDepth,
          selectedNode: widget.selectedNode,
          onNodeTap: widget.onNodeTap,
          canvasSize: Size(widget.availableWidth, widget.availableHeight),
          selectionAnimation: 1.0,
          pulseAnimation: 0.0,
          connectionAnimation: 1.0,
          nodeRadius: 30.0,
          verticalSpacing: 120.0,
          horizontalSpacing: 80.0,
        ),
      ),
    );
  }

  void _handleScaleStart(ScaleStartDetails details) {
    _previousScale = _scale;
    _previousOffset = _offset;
    _isPanning = false;
    _lastFocalPoint = details.focalPoint;
  }

  void _handleScaleUpdate(ScaleUpdateDetails details) {
    setState(() {
      _scale = (_previousScale * details.scale).clamp(0.5, 3.0);
      
      if (details.pointerCount > 1) {
        // Multi-finger gesture
        _isPanning = true;
        _offset = details.focalPoint - _previousOffset;
      } else if (_isPanning) {
        // Single finger pan
        _offset = _previousOffset + (details.focalPoint - _lastFocalPoint!);
      }
    });
  }

  void _handleScaleEnd(ScaleEndDetails details) {
    _previousScale = _scale;
    _previousOffset = _offset;
  }

  void _handleTap(Offset tapPosition, Size size) {
    // Calculate node positions and handle tap
    // This will be implemented in the painter
  }
}

class AnimatedGraphPainter extends CustomPainter {
  final Map<int, List<GraphNode>> nodesByDepth;
  final GraphNode? selectedNode;
  final Function(GraphNode) onNodeTap;
  final Size canvasSize;
  final double selectionAnimation;
  final double pulseAnimation;
  final double connectionAnimation;
  final double nodeRadius;
  final double verticalSpacing;
  final double horizontalSpacing;

  const AnimatedGraphPainter({
    required this.nodesByDepth,
    required this.selectedNode,
    required this.onNodeTap,
    required this.canvasSize,
    required this.selectionAnimation,
    required this.pulseAnimation,
    required this.connectionAnimation,
    required this.nodeRadius,
    required this.verticalSpacing,
    required this.horizontalSpacing,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // Draw background
    _drawBackground(canvas, size);

    // Calculate node positions
    final nodePositions = _calculateNodePositions(size);

    // Draw connections
    _drawConnections(canvas, nodePositions);

    // Draw nodes
    _drawNodes(canvas, nodePositions);
  }

  @override
  bool shouldRepaint(covariant AnimatedGraphPainter oldDelegate) {
    return nodesByDepth != oldDelegate.nodesByDepth ||
        selectedNode != oldDelegate.selectedNode ||
        selectionAnimation != oldDelegate.selectionAnimation ||
        pulseAnimation != oldDelegate.pulseAnimation ||
        connectionAnimation != oldDelegate.connectionAnimation;
  }

  void _drawBackground(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFFfefae0)
      ..style = PaintingStyle.fill;
    canvas.drawRect(Offset.zero & size, paint);
  }

  void _drawConnections(Canvas canvas, Map<GraphNode, Offset> nodePositions) {
    final paint = Paint()
      ..color = const Color(0xFFbc6c25)
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    for (final entry in nodePositions.entries) {
      final node = entry.key;
      final position = entry.value;

      for (final child in node.children) {
        if (nodePositions.containsKey(child)) {
          final childPosition = nodePositions[child]!;
          canvas.drawLine(position, childPosition, paint);
        }
      }
    }
  }

  void _drawNodes(Canvas canvas, Map<GraphNode, Offset> nodePositions) {
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
      textScaleFactor: 1.0,
    );

    for (final entry in nodePositions.entries) {
      final node = entry.key;
      final position = entry.value;
      final isSelected = node == selectedNode;

      // Draw node
      final paint = Paint()
        ..color = isSelected ? const Color(0xFF38b000) : const Color(0xFF4361ee)
        ..style = PaintingStyle.fill;

      // Add pulse effect for selected node
      final radius = nodeRadius * (isSelected ? (1.0 + 0.2 * math.sin(pulseAnimation * 2 * math.pi)) : 1.0);
      
      // Draw node shadow
      canvas.drawCircle(
        position + const Offset(2, 2),
        radius + 2,
        Paint()
          ..color = Colors.black.withOpacity(0.2)
          ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4),
      );

      // Draw node
      canvas.drawCircle(position, radius, paint);

      // Draw node border if selected
      if (isSelected) {
        canvas.drawCircle(
          position,
          radius + 2,
          Paint()
            ..color = Colors.white
            ..style = PaintingStyle.stroke
            ..strokeWidth = 2.0,
        );
      }

      // Draw node text
      final textSpan = TextSpan(
        text: node.label,
        style: GoogleFonts.roboto(
          color: isSelected ? Colors.white : Colors.black87,
          fontSize: 14,
          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
        ),
      );

      textPainter.text = textSpan;
      textPainter.layout();
      
      final textOffset = Offset(
        position.dx - textPainter.width / 2,
        position.dy - textPainter.height / 2,
      );
      textPainter.paint(canvas, textOffset);
    }
  }

  Map<GraphNode, Offset> _calculateNodePositions(Size size) {
    final Map<GraphNode, Offset> positions = {};
    if (nodesByDepth.isEmpty) return positions;

    // Calculate subtree widths for all nodes
    final subtreeWidths = _calculateSubtreeWidths();
    
    // Find root nodes (nodes with no parents)
    final Set<GraphNode> allNodes = {};
    final Set<GraphNode> children = {};
    
    nodesByDepth.values.forEach((nodes) {
      allNodes.addAll(nodes);
      nodes.forEach((node) {
        children.addAll(node.children);
      });
    });
    
    final List<GraphNode> rootNodes = allNodes.where((node) => !children.contains(node)).toList();
    
    // Position root nodes
    double currentX = size.width / 2; // Start from center
    for (final root in rootNodes) {
      final rootWidth = subtreeWidths[root] ?? 0.0;
      _assignPositions(
        root,
        currentX,
        50.0, // Top padding
        positions,
        subtreeWidths,
        verticalSpacing
      );
      currentX += rootWidth + horizontalSpacing * 2;
    }
    
    return positions;
  }

  Map<GraphNode, double> _calculateSubtreeWidths() {
    final Map<GraphNode, double> subtreeWidths = {};
    
    // Process nodes from bottom to top
    final depths = nodesByDepth.keys.toList()..sort((a, b) => b.compareTo(a));
    
    for (final depth in depths) {
      for (final node in nodesByDepth[depth]!) {
        if (node.children.isEmpty) {
          // Leaf nodes have a fixed width
          subtreeWidths[node] = nodeRadius * 4; // Base width for leaf nodes
        } else {
          // Calculate total width needed for children
          double totalWidth = 0.0;
          bool first = true;
          for (final child in node.children) {
            if (!first) {
              totalWidth += horizontalSpacing;
            }
            totalWidth += subtreeWidths[child] ?? 0.0;
            first = false;
          }
          subtreeWidths[node] = totalWidth;
        }
      }
    }
    
    return subtreeWidths;
  }

  void _assignPositions(
    GraphNode node,
    double x,
    double y,
    Map<GraphNode, Offset> positions,
    Map<GraphNode, double> subtreeWidths,
    double verticalSpacing
  ) {
    // If we've already positioned this node, return
    if (positions.containsKey(node)) return;
    
    // Position the current node
    positions[node] = Offset(x, y);
    
    // If it's a leaf node, we're done
    if (node.children.isEmpty) return;
    
    // Calculate total width of all children
    double totalWidth = 0.0;
    for (final child in node.children) {
      totalWidth += subtreeWidths[child] ?? 0.0;
    }
    
    // Add spacing between children
    if (node.children.length > 1) {
      totalWidth += (node.children.length - 1) * horizontalSpacing;
    }
    
    // Calculate starting x position to center children under parent
    double currentX = x - (totalWidth / 2);
    
    // Position each child
    for (final child in node.children) {
      final childWidth = subtreeWidths[child] ?? 0.0;
      _assignPositions(
        child,
        currentX + (childWidth / 2), // Center the child in its allocated space
        y + verticalSpacing,
        positions,
        subtreeWidths,
        verticalSpacing
      );
      currentX += childWidth + horizontalSpacing; // Move to next child position
    }
  }
}
